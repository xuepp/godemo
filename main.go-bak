package main

import (
	"fmt"

	"github.com/xuepp/godemo/pkg/functions"
)

// go程序启动时执行,优先于main()函数
// 可以同时定义多个init()函数
func init() {
	fmt.Println("Welcome to init() function")
}

func init() {
	fmt.Println("Hello! init() function")
}

// 这个主要引用function.go这个文件代码
func hanshu() {
	fmt.Println("------------以下是函数的逻辑------------------")
	//传int类型参
	fmt.Println(functions.FunctionDemo.Add(5, 4))
	//fmt.Println(functions.FunctionDemo.add(5, 4))
	//定义了函数返回int类型
	fmt.Println(test())
	//没有定义函数返回int类型
	test1()
	//延时调用hanshu函数,最后执行这个函数
	defer yanchi()
	//多个参数
	fmt.Println(joinstr("GEEK", "GFG"))
	fmt.Println(joinstr("Geeks", "for", "Geeks"))
	fmt.Println(joinstr("G", "E", "E", "k", "S"))
	//在可变函数中传递一个切片
	element := []string{"geeks", "FOR", "geeks"}
	fmt.Println("传递一个切片:", joinstr(element...))

	//调用全局匿名函数
	value()

	//在匿名函数传递参数
	func(ele string) {
		fmt.Println(ele)
	}("cainiaojc")

	//调用全局匿名函数，往函数里传参
	value2("cainiaojc")

	//局部定义一个匿名函数并赋值个aa
	aa := func(p, q string) string {
		return p + q + "Geeks"
	}
	//往函数里传递匿名函数
	GFG(aa)

	var Zz int = 10
	fmt.Printf("函数调用前，Zz的值为 = %d", Zz)

	//通过引用调用传递变量Z地址
	modifydata(&Zz)

	fmt.Printf("\n函数调用后，Zz的值为 = %d", Zz)

	var f int = 700
	var s int = 900

	fmt.Printf("函数调用前的值\n")
	fmt.Printf("f = %d 和 s = %d\n", f, s)

	//通过引用调用
	//传递变量地址
	swap(&f, &s)

	fmt.Printf("\n函数调用后的值\n")
	fmt.Printf("f = %d 和 s = %d", f, s)

	//将返回值分配到，三个不同的变量
	var myvar1, myvar2, myvar3 = myfunc(4, 2)

	// 显示值
	fmt.Printf("结果为: %d", myvar1)
	fmt.Printf("\n结果为: %d", myvar2)
	fmt.Printf("\n结果为: %d", myvar3)

	//将返回值分配到
	//两个不同的变量
	//var area1, area2 = myfunc2(2, 4)
	//_忽略值,go语言定义的变量没有使用会报错
	var area1, _ = myfunc2(2, 4)

	fmt.Printf("矩形面积为: %d", area1)
	//fmt.Printf("\n正方形面积为: %d", area2)

}

//	程序入口：Go 程序执行的起点，必须在 package main 包里定义。
//
// 只能有一个：每个程序（可执行包）只能有一个 main 函数。
// 没有参数和返回值：虽然可以通过 os.Args 获取命令行参数，但 main() 本身没有参数和返回值。
// 在所有 init 执行后才执行。
func main() {
	//hanshu()
	functions.FunctionDemo.test1()
}
